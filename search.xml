<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇文章</title>
    <url>/2021/02/26/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>这是一张图片</p>
<img src="/2021/02/26/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/example.jpeg" class="" title="this is an example image">]]></content>
  </entry>
  <entry>
    <title>13.罗马数字转整数</title>
    <url>/2021/03/06/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>本题思路简单，抓住罗马数字高位&gt;=低位用加法；高位&lt;低位用减法的本质能更快解题</p>
<img src="/2021/03/06/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0.jpg" class="">]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>7.整数反转</title>
    <url>/2021/03/03/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h4 id="leetcode-字节-7-整数反转"><a href="#leetcode-字节-7-整数反转" class="headerlink" title="leetcode 字节 7.整数反转"></a>leetcode 字节 7.整数反转</h4><p>这题第三解取自leetcode大神，位运算符既可以实现类似于C中的整除运算，又可数字判断是否溢出32位</p>


	<div class="row">
    <embed src="7.整数反转.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>babel+eslint配置使用私有变量和私有属性</title>
    <url>/2021/03/03/babel-eslint%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E5%92%8C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>在使用eslint为我的工程规范代码的时候，发现类私有域<code>#</code>还没有得到支持；好吧，它还在草案阶段。</p>
<img src="/2021/03/03/babel-eslint%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E5%92%8C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7/eslint%E6%8A%A5%E9%94%99.png" class="" title="eslint报错">
<p>所以我们首先要安装一个<code>npm i --save-dev @babel/eslint-parser</code>，它可以为eslint还不支持的语法提供支持，安装完后在eslint配置文件中设置<code>parser: &#39;@babel/parser&#39;</code>（我这里时.eslintrc.js）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">    es2021: <span class="literal">true</span>,</span><br><span class="line">    node: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;airbnb-base&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  parser: <span class="string">&#x27;@babel/parser&#x27;</span>,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaVersion: <span class="number">12</span>,</span><br><span class="line">    sourceType: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>到这里，babel已经能帮助我们的eslint规范它还不支持的语言特性，但是我们提到JavaScript的类私有域还在提案阶段，babel的preset-env还没有支持呢！所有需要安装两个babel插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i --save-dev @babel/plugin-proposal-class-properties @babel/plugin-proposal-private-methods</span><br></pre></td></tr></table></figure>
<p>然后在eslint配置文件添加<code>plugins: [&#39;classPrivateProperties&#39;, &#39;classPrivateMethods&#39;]</code>，至此报错消失，又可以愉快的使用类私有域了。<br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">    es2021: <span class="literal">true</span>,</span><br><span class="line">    node: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;airbnb-base&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  parser: <span class="string">&#x27;@babel/parser&#x27;</span>,</span><br><span class="line">  plugins: [<span class="string">&#x27;classPrivateProperties&#x27;</span>, <span class="string">&#x27;classPrivateMethods&#x27;</span>],</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaVersion: <span class="number">12</span>,</span><br><span class="line">    sourceType: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>babel, eslint, 前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>map+parseInt</title>
    <url>/2021/03/03/map-parseInt/</url>
    <content><![CDATA[<h1 id="对于-39-1-39-39-2-39-39-3-39-map-parseInt-的认知和理解"><a href="#对于-39-1-39-39-2-39-39-3-39-map-parseInt-的认知和理解" class="headerlink" title="对于[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)的认知和理解"></a>对于<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)</code>的认知和理解</h1><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>数组的map方法中的回调参数如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.map(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h4><p>parseInt将一个字符串（如果不是字符串，<code>tostring</code>转化为字符串）转换为一个number类型的整数，并可以指定这个字符串的进制；范围2-36，默认为10进制；<br>如果radix是0 or <code>undefined</code>，则string以<code>0x</code>, <code>0X</code>开头是16进制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(string, radix = <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>上面的表达式实际上的调用是这样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>].map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(item, index);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果是<code>[parseInt(&#39;1&#39;, 0), parseInt(&#39;2&#39;, 1), parseInt(&#39;3&#39;, 2)]</code>即为<code>[1, NaN, NaN]</code></p>
<h4 id="进一步理解"><a href="#进一步理解" class="headerlink" title="进一步理解"></a>进一步理解</h4><p>可以看到题目的需求可能是循环遍历一个字符串数字，用<code>Number</code>可以满足需求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;].map(Number)`</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次Javascript-Library搭建过程</title>
    <url>/2021/03/09/%E8%AE%B0%E4%B8%80%E6%AC%A1Javascript-Library%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>随着前端工程化的普及使用，构建一个现代的JavaScript库是愈发复杂，恰好有构建一个js库的需求，现在就从零开始搭建。<br>考虑到搭建js库大家都推荐rollup，一是自带tree-shaking，二是打包出来的代码更简洁，冗余代码少。但是webpack已经是前端必学的打包工具了，本次搭建先使用webpack，后续考虑使用rollup重新搭建并做对比。</p>
<h4 id="前端工程化的工具"><a href="#前端工程化的工具" class="headerlink" title="前端工程化的工具"></a>前端工程化的工具</h4><ul>
<li>打包工具：webpack</li>
<li>js编译器：babel</li>
<li>代码规范：eslint</li>
<li>单元测试：jest</li>
<li>API文档生成：jsdoc</li>
</ul>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><img src="/2021/03/09/%E8%AE%B0%E4%B8%80%E6%AC%A1Javascript-Library%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/%E7%9B%AE%E5%BD%95.png" class="">

<p>这是目录结构，每个文件夹代表不同的职责：</p>
<ul>
<li>build：这里存储babel转化好的代码，待npm包发布后commonjs调用该部分的代码，这是经过转化但是未压缩的代码。jsdoc生成的api文档也暂存在这里</li>
<li>config：这里存储jsdoc的个性化配置脚本和文档生成文件，如果只是简单的生成jsdoc文档这里可以忽略</li>
<li>demo：这是可以写API简单应用的示例，告诉使用者如何使用</li>
<li>dist：webpack+babel生成的浏览器可运行的amd类型的打包好的代码存储在这里</li>
<li>src：这里是源码</li>
<li>test：一个合格的库必须要有完备的测试用例，用起来，这将是你走向单元测试的第一步</li>
</ul>
<h4 id="起步：创建npm项目"><a href="#起步：创建npm项目" class="headerlink" title="起步：创建npm项目"></a>起步：创建npm项目</h4><p>首先创建一个npm项目，填写好项目的name，description等。。。。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>

<h4 id="安装eslint"><a href="#安装eslint" class="headerlink" title="安装eslint"></a>安装eslint</h4><p>先全局安装一个eslint包，也可以使用npx命令，在当前目录下创建eslint配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// npx eslint --init 或者下面这两行</span><br><span class="line">npm install eslint -g</span><br><span class="line">eslint --init</span><br></pre></td></tr></table></figure>

<p>具体的配置可按提示一步一步选择，待选择完成后eslint会安装对应的npm包和插件，并配置到package.json的<code>devDependenceies</code>中。我这里使用了import的导入方式，airbnb的代码规范，最终会添加下面三个依赖。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;eslint&quot;: &quot;^7.21.0&quot;,</span><br><span class="line">    &quot;eslint-config-airbnb-base&quot;: &quot;^14.2.1&quot;,</span><br><span class="line">    &quot;eslint-plugin-import&quot;: &quot;^2.22.1&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>还会在项目根目录生成eslint配置文件.eslintrc.js（JSON或JS文件，我这里JS），可以看到配置中env浏览器环境和node环境都是允许的，并且可以lint最新的es2021代码规范；</p>
<p>extends里面是我们所使用的代码规范标准，我这里选择的airbnb（视个人喜好，项目要求而定）</p>
<p>parserOptions可以定制支持的js语言，默认支持ES5的代码，<code>ecmaVersion</code>可以将支持的环境提升到12，<code>sourceType</code>源码类型默认是script，如果是esm类型可以将其改成<code>module</code>，</p>
<p>rules允许自定义eslint部分规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: true,</span><br><span class="line">    es2021: true,</span><br><span class="line">    node: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  extends: [</span><br><span class="line">    &#39;airbnb-base&#39;,</span><br><span class="line">  ],</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaVersion: 12,</span><br><span class="line">    sourceType: &#39;module&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>到这里，eslint的基本配置就好了，但是eslint不认识的代码我们还需要配合babel来使用，别急，接下来还会再见。</p>
<h4 id="安装babel"><a href="#安装babel" class="headerlink" title="安装babel"></a>安装babel</h4><p>如今webpack已经遇到了诸多对手：rollup，parcel甚至是vite；但是babel却鲜有对手，所以必须要学会babel的配置。</p>
<p>此项目安装babel的目标是只将源码babel转换而不用webpack打包，这部分能用使用commonjs或esm的形式引入即可。</p>
<p>babel主要有2个配置：preset和plugins</p>
<p>首先安装babel的核心依赖</p>
<ul>
<li><code>@babel/core</code>是babel的核心，它将高版本的ES代码转化成低版本的ES代码</li>
<li><code>@babel/cli</code>允许我们以命令行的方式运行babel</li>
<li><code>@babel/preset-env</code>是babel预设的一组插件，它可以根据targets智能地为浏览器不支持的方法polyfill，配合<code>useBuiltIns</code>可以按需加载</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/core @babel/cli @babel/preset-env</span><br></pre></td></tr></table></figure>

<p>然后手动创建一个babel的配置文件babel.config.json，做一些基础的设置，</p>
<p>这里的targets指定各个浏览器的版本，他们不支持的语法由babel负责转换，<code>useBuiltIns:usage</code>指示babel只按需加载用到的polyfill而无需将所有polyfill全部载入；</p>
<p><code>corejs</code>指示corejs的次要版本，当<code>@babel/preset-env</code>中的corejs不支持某种polyfill时便可以使用指定版本的polyfill；corejs默认不对提案做polyfill，所以这是可选项，这里我默认把它加上（我也不知道有什么影响，先以防万一用到）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;targets&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;edge&quot;</span>: <span class="string">&quot;17&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;firefox&quot;</span>: <span class="string">&quot;60&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;chrome&quot;</span>: <span class="string">&quot;67&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;safari&quot;</span>: <span class="string">&quot;11.1&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;node&quot;</span>: <span class="string">&quot;current&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;corejs&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;3.9.1&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;proposals&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>写JavaScript库时建议用<code>@babel/plugin-transform-runitme + @babel/runtime-corejs3</code>，然后在babel.config.json中设置<code>&quot;useBuiltIns&quot;: false</code>然后删除紧接着的corejs设置；</p>
<p>具体这两种poly fill的差别可以查看以下两个博文，非常仔细且易于理解</p>
<p><a class="link"   href="https://blog.liuyunzhuge.com/2019/09/04/babel%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89-polyfill%E5%92%8Cruntime/" >babel详解（五）:polyfill和runtime<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://segmentfault.com/a/1190000021188054" >@babel/preset-env 与@babel/plugin-transform-runtime 使用及场景区别<i class="fas fa-external-link-alt"></i></a></p>
<p>首先安装这两个插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-transform-runitme</span><br><span class="line">npm install --save @babel/runtime-corejs3</span><br></pre></td></tr></table></figure>

<p>在plugins中添加插件<code>@babel/plugin-transform-runitme</code>，这里的设置<code>&quot;corejs&quot;: 3</code>告诉babel我要使用``@babel/runtime-corejs3`来为我polyfill啦</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">  [<span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="attr">&quot;corejs&quot;</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>最后别忘了提醒开发者在自己的项目中安装<code>@babel/runtime-corejs3</code>，可以在<code>perDependencies</code>添加。</p>
<h4 id="eslint-babel：支持最新语法的eslint"><a href="#eslint-babel：支持最新语法的eslint" class="headerlink" title="eslint + babel：支持最新语法的eslint"></a>eslint + babel：支持最新语法的eslint</h4><p>到这里你已经可以发现，当你写最新的代码的时候，比如类私有域（最新的提案）的时候eslint提示暂不支持，这时就需要babel来帮忙，将eslint的解析器设置为<code>@babel/parser</code>让eslint支持babel合法的语法。</p>
<p>首先安装支持的js类私有域的babel插件和babel-eslint解析器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/eslint-parser @babel/plugin-proposal-class-properties @babel/plugin-proposal-private-methods</span><br></pre></td></tr></table></figure>

<p>然后在eslint配置文件（.eslintrc.js）中添加插件和解析器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parser: <span class="string">&#x27;@babel/parser&#x27;</span>,</span><br><span class="line">plugins: [<span class="string">&#x27;classPrivateProperties&#x27;</span>, <span class="string">&#x27;classPrivateMethods&#x27;</span>],</span><br></pre></td></tr></table></figure>

<p>同样的在babel也需要转换这部分代码，所以在babel.config.json也需要添加对应的插件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">  &quot;@babel/plugin-proposal-class-properties&quot;,</span><br><span class="line">  <span class="string">&quot;@babel/plugin-proposal-private-methods&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>可以参考一下此时完整的eslint文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">    es2021: <span class="literal">true</span>,</span><br><span class="line">    node: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;airbnb-base&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  parser: <span class="string">&#x27;@babel/parser&#x27;</span>,</span><br><span class="line">  plugins: [<span class="string">&#x27;classPrivateProperties&#x27;</span>, <span class="string">&#x27;classPrivateMethods&#x27;</span>],</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaVersion: <span class="number">12</span>,</span><br><span class="line">    sourceType: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时我们的eslint和babel都支持类私有域的lint和转换了</p>
<h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><p>如今webpack + babel已经是很多npm项目的标配了，</p>
<p>这里安装webpack的目的是将我们的源码以umd的形式打包成一个文件，方便浏览器引入；同时也支持amd和commonjs的方式引入。</p>
<p>首先安装webpack的核心包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack webpack-cli</span><br></pre></td></tr></table></figure>

<p>如果你需要打包的同时分析打包文件各个依赖的大小，可以安装<code>webpack-bundle-analyzer</code>这个插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-bundle-analyzer</span><br></pre></td></tr></table></figure>

<p>为了让我们的webpack在打包的时候自动使用babel转译js代码，需要安装一个babel-loader，如何使用我们将稍后使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-loader</span><br></pre></td></tr></table></figure>

<p>然后手动创建一个webpack.config.js</p>
<p>配置如下，我们稍后做一下讲解</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>).BundleAnalyzerPlugin;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/hxol/index.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;hxol.js&#x27;</span>,</span><br><span class="line">    library: <span class="string">&#x27;hxol&#x27;</span>,</span><br><span class="line">    libraryTarget: <span class="string">&#x27;umd&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.m?js/</span>,</span><br><span class="line">        exclude: <span class="regexp">/(node_modules)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>entry是程序的入口，很好理解；我们可以将我们需要打包的文件在index.js中import再export出来；webpack会根据依赖自动打包</li>
<li>output是文件的输出位置和格式<ul>
<li>path指定输出路径</li>
<li>filename指示输出文件名</li>
<li>library指示我们暴露的全局变量的名称</li>
<li>libraryTarget则指示我们输出的类型，这里使用umd，即amd，cmd，浏览器都可以导入</li>
</ul>
</li>
<li>module指导webpack如何处理不同的模块，上面的规则规定我们转化js/mjs文件，排除node_modules文件夹并使用babel-loader转译</li>
<li>plugins则是我们使用webpack可能会用的插件，这个<code>webpack-bundle-analyzer</code>可以在打包的时候生成一个各个依赖占用大小的报告</li>
</ul>
<h4 id="jest-单元测试"><a href="#jest-单元测试" class="headerlink" title="jest 单元测试"></a>jest 单元测试</h4><p>jest进行单元测试就比较简单了，它会自动寻找babel的配置文件并在测试的时候使用babel转译代码，但是jest会自动不转译node_modules中的代码，有转译需求的小伙伴创建一个jest.config.js配置文件，配置如下即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 转换node_modules中的代码</span></span><br><span class="line">  transformIgnorePatterns: [],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然jest很智能，但它发现babel有test相关的环境时会优先使用test环境去使用babel转译，这样我们就可以为jest定制一个babel配置，这不是必须的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;env&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">        [</span><br><span class="line">          <span class="string">&quot;@babel/env&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">&quot;targets&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;node&quot;</span>: <span class="string">&quot;current&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">            <span class="string">&quot;corejs&quot;</span>: <span class="string">&quot;3.9.1&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>最后所有插件都安装好了，我们可以在src中写源码了，然后进行转译，打包，api生成。可以在package.json中配置这些脚本。</p>
<ul>
<li>转译：<code>babel your/src/path --out-dir your/dist/path</code>，babel会自动使用目录下的babel配置，这是npm publish后node项目引入时的文件地址</li>
<li>打包：webpack –mode=production，webpack会自动使用目录下的webpack配置，这是浏览器可以引用的代码，当然node项目也可以引入</li>
<li>生成API：jsdoc</li>
<li>测试：jest，同样的，会自动使用jest配置文件</li>
</ul>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>书写百变，其义自现。前端工程化的配置光看只能理解表面，多实践才能记住。</p>
]]></content>
      <tags>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>递归-字节206反转链表</title>
    <url>/2021/03/10/%E9%80%92%E5%BD%92-%E5%AD%97%E8%8A%82206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>递归的思想在代码中已经屡见不鲜，透过本题先熟悉递归的可解决的问题：</p>
<ol>
<li>1个大问题可以分解成2个子问题</li>
<li>子问题的求解方式和大问题相同</li>
<li>存在最小的子问题<br>大问题分解成子问题是递归调用来实现；<br>子问题的求解在归的过程中完成；<br>最小子问题就是递归调用结束的条件；因为此时已经递归调用到最底层，问题不可再分。<br>代码结构大体上可分为5个部分：<br>结束条件 =&gt; 递的过程做的事情 =&gt; 递归调用 =&gt; 归的过程做的事情 =&gt; 返回结果<img src="/2021/03/10/%E9%80%92%E5%BD%92-%E5%AD%97%E8%8A%82206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.jpg" class=""></li>
</ol>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>css中的BEM</title>
    <url>/2021/03/16/css%E4%B8%AD%E7%9A%84BEM/</url>
    <content><![CDATA[<h4 id="什么是BEM？"><a href="#什么是BEM？" class="headerlink" title="什么是BEM？"></a>什么是BEM？</h4><p>BEM是Block，Element，Modifier的简称；是一种在项目中书写css类名的方式；<br>它的思想是将用户界面分割成不同的部分，然后更好的重用那些重复的部分。</p>
<p>BEM书写的css类名由三个部分组成<code>Block-name__Element-name_Modifier-name</code>，使用单破折号<code>-</code>连接一个部分的词组，举例<code>search-form</code>因为它的用两个单词代表一个块Block，所以在单词间使用；<br>用双下划线<code>__</code>连接块和元素；用单划线<code>_</code>连接块和修饰符，元素和修饰符。</p>
<h4 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h4><p>Block的中文翻译块，概念上相当于一个名词空间，一个包含众多属性的类，可以是用户界面的一个模块；<br>比如页头的class类名可以是<code>header</code>，一个搜索的表单的类名是<code>search-form</code>；</p>
<p>这个叫块的类名是可以嵌套的，也就是说一个外层元素的类名是一个只包含Block类型的class，内层元素依然可以是一个只包含Block类型的class，嵌套的层级没有限制；<br>因为一个块是可以重用的，所以它的css属性不应该影响它周围的环境，所以Block设置外边距margin，位置position都是不允许的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;search-form&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h4><p>Element是一个元素，概念上相当于类中的属性，是一个模块的一部分的名称，它和块用双下划线连接<code>__</code>；<br>比如一个搜索表单中的搜索框可以是<code>search-form__input</code>，查询按钮可以是<code>search-form__query-button</code>;</p>
<p>元素这种类型的类名不能单独存在，必须配合块Block使用，不配合它自己不就变成Block了吗；<br>元素间的类名没有明显的嵌套关系，你可以自由组合他们；<code>search-form__input</code>可以在<code>search-form__body</code>内部，也可以是它的平级;<br>类名中一个块Block只能有一个元素Element，不能这么使用<code>search-form__body__input</code>，如果你真的想语义化表达一个body中的输入框可以尝试<code>search-form__body-input</code> 。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;search-form&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;search-form__body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;search-form__input&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;search-form__input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Block与Element之间的选择"><a href="#Block与Element之间的选择" class="headerlink" title="Block与Element之间的选择"></a>Block与Element之间的选择</h4><h5 id="什么时候使用Block？"><a href="#什么时候使用Block？" class="headerlink" title="什么时候使用Block？"></a>什么时候使用Block？</h5><p>当这部分代码可能被重用，并且不受周围的组件的实现影响的话，就可以创建一个块类型的class。</p>
<h5 id="什么时候使用Element？"><a href="#什么时候使用Element？" class="headerlink" title="什么时候使用Element？"></a>什么时候使用Element？</h5><p>当这部分重用的代码不能单独使用，必须依赖一个外部的环境；这个代表外部的环境代码块就可以用Block的类名，而这部分代码可以使用元素Element；<br>例如一个表单的查询按钮的样式不能单独存在，必须被一个表单包裹，这个表单的类名可以是<code>search-form</code>，这个查询按钮的类名可以是<code>search-form__query-button</code>。</p>
<p>当我们需要把代码块分成更小的部分的时候，由于BEM规则下不允许出现<code>block__elem1__elem2</code>这样的类名；所以可以把外部代码块的类名定义成一个Block，内部的各个小代码块是Element，如一个搜索框分为用户输入部分和提示部分，就可以定义<code>input-box__input</code>和<code>input-box__prompt</code>。</p>
<h4 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h4><p>Modifier是一个修饰符，用来修饰块Block或元素Element的外观，状态，行为；<br>如果想表示一个元素或块的某个状态，可以用<code>block_modifier</code>，<code>block__element_modifier</code>的形式；举个例子，想要描述一个表单中被点击过的按钮，它的样式可以这么表示<code>form__button_clicked</code>。想描述一个横向排列的按钮块可以这么表示<code>button-group_horizontal</code>；<br>如果想表示一个元素或某个块的某个属性的状态呢，可以用<code>key_value</code>的模式，他们也用单下划线连接；用公式可以表示为<code>block_modifier-key_modifier-value</code>；如果想要表示一个表单的高度是200px，可以这么写<code>form_height_200</code>。</p>
<p>表示修饰符的类名不能单独与块或元素使用，只能起到修饰的作用，比如表示一个高度为200px的表单不能这么写，缺少了块</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_height_200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>必须要包含一个块或元素，这才是正确的写法，要记住Modifier只起到修饰的作用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form form_height_200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h4><p>让我们结合一个示例来描述</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- `header` block --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        The `search-form` block is mixed with the `search-form` element</span></span><br><span class="line"><span class="comment">        from the `header` block</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;search-form header__search-form&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子中，我们在header块中重用了<code>search-form</code>这个块，<code>search-form</code>是描述搜索表单的一个块，在header块中我们需要在<code>search-form</code>的基础上添加一些只在header中特有的样式，所以可以添加一个<code>header__search-form</code>，两个组合使用可以重用<code>search-form</code>中的样式，在<code>header__search-form</code>中又可以定制化一些样式。</p>
<p>一个使用BEM的组成的组件可以是这样子的</p>
<img src="/2021/03/16/css%E4%B8%AD%E7%9A%84BEM/%E4%B8%80%E4%B8%AABEM%E7%9A%84%E7%BB%84%E6%88%90.jpeg" class="">
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>节流之见解</title>
    <url>/2021/03/22/%E8%8A%82%E6%B5%81%E4%B9%8B%E8%A7%81%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="什么是节流？"><a href="#什么是节流？" class="headerlink" title="什么是节流？"></a>什么是节流？</h4><p>节流很容易让我们想到节流阀，不管输入的水流量有多大，总可以通过节流阀控制水流出的速度。<br>JavaScript中的节流有同样的效果，即对于一个节流函数，不管触发的频率有多快，一段事件内只执行一次。<br>就像《防抖之见解》中的小蜜蜂，它现在的工作模式变成了如果你摸它的速度在1s/次以内，它总是以1s/次的速度闪烁；如果摸它的速度慢于1s/次，则它摸一次闪一次。</p>
<h4 id="节流的应用场景"><a href="#节流的应用场景" class="headerlink" title="节流的应用场景"></a>节流的应用场景</h4><p>window的scroll方法，input的通过远程请求的实时搜索建议可以做成节流。</p>
<h4 id="Version-1-基于Date的实现"><a href="#Version-1-基于Date的实现" class="headerlink" title="Version 1 基于Date的实现"></a>Version 1 基于Date的实现</h4><p>实现的思路如下：用闭包保存上一次触发函数的时间lastTime，计算现在now时刻和上一次触发的的时差<code>now-lastTime</code>，时差小于设定的阈值则不执行函数并更新lastTime为now。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttleV1</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (now - lastTime &gt;= delay) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      lastTime = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Version-1——setTimeout-基于timeout的实现"><a href="#Version-1——setTimeout-基于timeout的实现" class="headerlink" title="Version 1——setTimeout 基于timeout的实现"></a>Version 1——setTimeout 基于timeout的实现</h4><p>基本的节流也可用setTimeout实现，思路类似：如果本次进入函数还存在一个计时器，则不执行；不存在计时器则执行函数并创建一个新的计时器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttleV1_timeout</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Version-2-有附加功能的节流器"><a href="#Version-2-有附加功能的节流器" class="headerlink" title="Version 2 有附加功能的节流器"></a>Version 2 有附加功能的节流器</h4><p>以上的两种实现第一次进入的时候都会执行函数，如果现在有一些需求，比如第一次进入的时候是否需要触发，最后离开的时候是否需要触发最后一次，可以在节流函数添加一个option，leading参数代表第一次执行是否触发，trailing代表最后一次离开后是否再次执行；</p>
<p>这个节流器的主要部分可以用Date实现，上面的实现是第一次触发即执行函数；如果第一次触发不想执行函数呢？由于闭包的存在，很容易保存一个状态表示是否第一次进入函数。</p>
<p>最后一次离开后是否再次执行可以用setTimeout，我们在每次触发函数的时候设定一个计时器，延时为设定的delay，下次进入的时候清除这个计时器并重新设定一个；<br>如果这个节流函数不再触发，便可触发我们设定的setTimeout，最后执行一次函数。如果在delay时间内再触发节流函数，则重新设定延时，上次setTimeout中的函数不会触发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttleV3</span>(<span class="params">fn, delay, option = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">let</span> leading = option.leading === <span class="literal">false</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> trailing = option.trailing === <span class="literal">true</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (!leading) &#123;</span><br><span class="line">      lastTime = now;</span><br><span class="line">      leading = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now - lastTime &gt;= delay) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      lastTime = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (trailing) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加一个取消节流的函数"><a href="#添加一个取消节流的函数" class="headerlink" title="添加一个取消节流的函数"></a>添加一个取消节流的函数</h4><p>和防抖一样，我们需要一个后悔药：取消函数节流，让他像正常函数一样执行；可以添加一个cancel方法。实现思路也和防抖一样，添加一个cancel的tag</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttleV4</span>(<span class="params">fn, delay, option = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">let</span> cancel = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> leading = option.leading === <span class="literal">false</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> trailing = option.trailing === <span class="literal">true</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> throttled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cancel) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (!leading) &#123;</span><br><span class="line">      lastTime = now;</span><br><span class="line">      leading = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now - lastTime &gt;= delay) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      lastTime = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (trailing) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  throttled.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    cancel = <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/03/22/%E8%8A%82%E6%B5%81%E4%B9%8B%E8%A7%81%E8%A7%A3/%E8%8A%82%E6%B5%81.gif" class="">
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖之见解</title>
    <url>/2021/03/18/%E9%98%B2%E6%8A%96%E4%B9%8B%E8%A7%81%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="什么是防抖？"><a href="#什么是防抖？" class="headerlink" title="什么是防抖？"></a>什么是防抖？</h4><p>防抖是一个晦涩难懂的名词，先举个例子：有一只可爱的萤火虫，只要摸它一下，它在一秒之后就会闪一下；但是如果你以迅雷不及掩耳之势一秒摸它10次，那它在一秒后亮10次，可能要累死它。<br>于是它就想了一个办法，只要你摸了它一下之后下一秒内如果没有再碰它那他就会友好的亮灯；否则他会再等一秒，直到你在这一秒内不再摸它，它才会亮灯。</p>
<p>在计算机中防抖就是在用户频繁触发一个事件的时候，无论触发多少次，只要事件之间时间间隔在规定的n秒内，那事件就不会执行直到n秒后执行最后一个事件，它把连续多次触发转换为触发最后一次。</p>
<p>它可以这么表示：</p>
<img src="/2021/03/18/%E9%98%B2%E6%8A%96%E4%B9%8B%E8%A7%81%E8%A7%A3/%E9%98%B2%E6%8A%96.jpg" class="">

<h4 id="防抖的应用场景"><a href="#防抖的应用场景" class="headerlink" title="防抖的应用场景"></a>防抖的应用场景</h4><p>它优化了一些性能问题，计算机不必一直执行用户的操作，只要在最后一次触发。比如用户容易频繁触发的频繁点击鼠标的mousedown事件，频繁移动鼠标的mouseover事件；用户缩放窗口的window resize事件；<br>用户输入表单频繁触发的change事件。</p>
<h4 id="Version-1-实现一个最简单的防抖函数"><a href="#Version-1-实现一个最简单的防抖函数" class="headerlink" title="Version 1 实现一个最简单的防抖函数"></a>Version 1 实现一个最简单的防抖函数</h4><p>防抖函数包装一个原始的函数fn，并设定一个延迟的时长delay，返回一个函数；</p>
<p>这个防抖函数使用闭包和setTiemout实现；闭包是为了保存定时器timer；</p>
<ul>
<li>第一次执行的时候<code>clearTimeout(timer)</code>没什么用；所以首先创建一个定时器，它预期会在delay毫秒后执行fn函数</li>
<li>如果delay毫秒内这个函数不再执行，那fn就会触发；</li>
<li>如果delay毫秒内这个函数再次触发，<code>clearTimeout(timer)</code>会清除定时器，那么fn不再执行；重新创建一个定时器它会在这次触发的delay毫秒后执行fn函数，达到了防抖的目的。</li>
</ul>
<p>但是它没有考虑到this指向问题；如果fn包含参数那么这个参数也获取不到了。</p>
<blockquote>
<p>为什么this指向有问题？</p>
<p>因为this指向的是它函数所在的执行环境，比如执行一个全局函数a，它的实际调用是golbalThis.a()；那么它的a的执行环境就是globalThis，this指向globalThis；</p>
<p>回调函数同理，因为回调函数fn前面没有显性对象调用它，那么它的执行环境就是globalThis，this执行globalThis。所以要纠正this指向，不然fn内的this会发生错乱。</p>
</blockquote>
<blockquote>
<p>为什么参数会丢失？</p>
<p>以下面的setTimeout为例，当我们把fn作为第一个参数传入是实际上是传入了fn函数地址或者说引用，告诉setTimeout当执行开始执行回调的时候去执行fn函数吧，因为执行一个函数只需要给它加上一对括号即可，所以执行fn函数在表达上就是<code>fn()</code>，而我们的参数并没有传入，此时我们可以在外面包裹一层匿名函数并传入我们想要的参数，在下个版本的实现中可以看到。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounceV1</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(fn, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><img src="/2021/03/18/%E9%98%B2%E6%8A%96%E4%B9%8B%E8%A7%81%E8%A7%A3/v1.gif" class=""></center>

<h4 id="Version-2-添加this指向，正确传入参数"><a href="#Version-2-添加this指向，正确传入参数" class="headerlink" title="Version 2 添加this指向，正确传入参数"></a>Version 2 添加this指向，正确传入参数</h4><p>下面的实现修正了Version 1的问题；</p>
<p>我们首先确定什么是this指向正确，它的意义是：执行原始函数的时候，原始函数x内部的this指向的是原始函数的执行环境；当我们尝试对原始函数x做一些包装，赋予它一些额外的能力的时候（比如防抖的功能），包装后生成的函数y在执行x的时候我们期望x内部的this指向y所在的执行环境。</p>
<p>由于箭头函数的没有自己的this和arguemnts，那么箭头函数内的this和arguments总是它外层环境的，相当于this确定了即<code>return function</code>中的this，这个函数暂且叫h。</p>
<p>包裹前的函数是fn，包裹后的函数是h，当fn执行的时候fn内部的this即h的this，此时我们可以说this指向正确了；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounceV2</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="comment">// 包裹后的函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Version-3-第一次立即执行的防抖函数"><a href="#Version-3-第一次立即执行的防抖函数" class="headerlink" title="Version 3 第一次立即执行的防抖函数"></a>Version 3 第一次立即执行的防抖函数</h4><p>现在我们要对防抖函数做出一些定制，要求它第一次触发立即执行。如果这不是爱捣乱的用户，那他就不会受到延迟delay毫秒的惩罚；</p>
<p>由于它本身就是一个闭包函数，可以存储私有变量，所以我们就可以用一个tag：first来标识是否是第一次触发函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounceV3</span>(<span class="params">fn, delay, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> first = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    <span class="keyword">if</span> (first &amp;&amp; immediate) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      first = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><img src="/2021/03/18/%E9%98%B2%E6%8A%96%E4%B9%8B%E8%A7%81%E8%A7%A3/v3.gif" class=""></center>

<h4 id="Version-4-带有返回值的防抖函数"><a href="#Version-4-带有返回值的防抖函数" class="headerlink" title="Version 4 带有返回值的防抖函数"></a>Version 4 带有返回值的防抖函数</h4><p>因为防抖函数天生自带延迟，所以我们只要求在第一次执行的时候返回值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounceV4</span>(<span class="params">fn ,delay, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">let</span> first = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    <span class="keyword">if</span> (first &amp;&amp; immediate) &#123;</span><br><span class="line">      result = fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      first = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Version-5-可以取消的防抖函数"><a href="#Version-5-可以取消的防抖函数" class="headerlink" title="Version 5 可以取消的防抖函数"></a>Version 5 可以取消的防抖函数</h4><p>防抖函数a在使用<code>a.cancel()</code>后就能恢复成原来的函数，不防抖了;</p>
<p>这一版中我们为返回的函数添加一个cancel方法，依旧使用私有变量+tag的模式；通过表示确定我们函数运行的模式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounceV5</span>(<span class="params">fn ,delay, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">let</span> cancel = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> debounced = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    <span class="keyword">if</span> ((!timer &amp;&amp; immediate) || cancel) &#123;</span><br><span class="line">      result = fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      timer = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    cancel = <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><img src="/2021/03/18/%E9%98%B2%E6%8A%96%E4%B9%8B%E8%A7%81%E8%A7%A3/v5.gif" class=""></center>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
